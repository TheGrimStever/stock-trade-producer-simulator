/*
 * This source file was generated by the Gradle 'init' task
 */
package com.enterprises.baca

import org.apache.kafka.clients.producer.KafkaProducer
import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.clients.producer.ProducerRecord
import org.json.JSONObject
import java.util.*
import kotlin.random.Random
import kotlin.time.Clock
import kotlin.time.ExperimentalTime

fun main() {

    val random = Random
    val tickerList = getTickerList()
    val kafkaProps = setupKafkaProps()

    KafkaProducer<String, String>(kafkaProps).use { producer ->

        Runtime.getRuntime().addShutdownHook(Thread {
            println("Shutting down, closing Kafka producer...")
            producer.close()
        })

        while (true) {
            try {
                val tradeJson = generateFakeTrade(tickerList, random)

                val record = ProducerRecord<String, String>(
                    "trades",
                    tradeJson.getString("ticker"),
                    tradeJson.toString()
                )

                producer.send(record) { metadata, exception ->
                    exception?.let {
                        System.err.println("Failed to send: ${it.message}")
                    }
                }
                Thread.sleep(100)
            } catch (e: Exception) {
                e.printStackTrace()
                break
            }
        }
    }
}

fun getTickerList(): List<String> {
    val tickers: List<String> = {}.javaClass.classLoader.readResourceLines("tickers.txt")

    return tickers
}

fun setupKafkaProps(): Properties {

    return Properties().apply {
        put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092")
        put(ProducerConfig.LINGER_MS_CONFIG, 1)
        put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer")
        put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer")
        put(ProducerConfig.ACKS_CONFIG, "all")
    }
}

@OptIn(ExperimentalTime::class)
fun generateFakeTrade(tickers: List<String>, random: Random): JSONObject {

    val symbol = tickers.random()
    val price = 100 + random.nextDouble() * 100
    val volume = 1 + random.nextInt(until = 1000)
    val timestamp = Clock.System.now().toEpochMilliseconds()

    return JSONObject().apply {
        put("ticker", symbol)
        put("price", price)
        put("volume", volume)
        put("timestamp", timestamp)
    }
}

fun ClassLoader.readResourceLines(path: String): List<String> =
    getResourceAsStream(path)
        ?.bufferedReader()
        ?.useLines { it.toList() }
        ?: throw IllegalArgumentException("Resource not found: $path")